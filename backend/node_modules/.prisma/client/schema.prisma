generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/**
 * ---------- Enums ----------
 */

enum TemplateStatus {
  active
  inactive
  archived
}

/**
 * ---------- Core models ----------
 */

model WaveBucket {
  waveId String
  name   String // bucket name, e.g., "conversation_checkin"

  wave Wave @relation(fields: [waveId], references: [id])

  // back-relations
  templates    Template[]    @relation("TemplateToWaveBucket")
  microActions MicroAction[] @relation("MicroActionToWaveBucket")

  @@id([waveId, name]) // composite PK for FK references
}

model Template {
  id            String         @id @default(cuid())
  waveId        String
  bucket        String
  textPattern   String
  modifiersJson Json           @default("{}")
  status        TemplateStatus @default(active)
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt

  // relations
  wave         Wave          @relation("TemplateToWave", fields: [waveId], references: [id])
  waveBucket   WaveBucket    @relation("TemplateToWaveBucket", fields: [waveId, bucket], references: [waveId, name])
  microActions MicroAction[] @relation("TemplateToMicroAction")

  @@index([waveId, bucket])
}

model User {
  id           String   @id @default(cuid())
  email        String   @unique
  passwordHash String
  createdAt    DateTime @default(now())

  // Dream is now just a profile field
  dream String?

  // 1:N memberships
  memberships UserRipple[] @relation("UserToMemberships")

  actionLogs ActionLog[] @relation("UserToActionLogs")
}

model Wave {
  id             String  @id @default(cuid())
  name           String  @unique
  description    String
  icon           String?
  impactCoef     Float
  impactUnit     String
  impactSource   String
  allowedBuckets String // comma-separated list

  ripples      Ripple[]      @relation("WaveToRipples")
  actionLogs   ActionLog[]   @relation("WaveToActionLogs")
  waveBuckets  WaveBucket[]
  templates    Template[]    @relation("TemplateToWave")
  microActions MicroAction[] @relation("WaveToMicroActions")
}

//a rippl that is attached to a user
model UserRipple {
  id        String   @id @default(cuid())
  userId    String
  rippleId  String
  isActive  Boolean  @default(true)
  isPrimary Boolean  @default(false)
  joinedAt  DateTime @default(now())

  // name the relations explicitly
  user   User   @relation("UserToMemberships", fields: [userId], references: [id])
  ripple Ripple @relation("RippleToMemberships", fields: [rippleId], references: [id])

  @@unique([userId, rippleId])
  @@index([userId, isPrimary])
}

//model used to generate blurb info for community tab
model RippleActivity {
  id        String   @id @default(cuid())
  rippleId  String
  city      String?
  blurb     String
  createdAt DateTime @default(now())

  ripple Ripple @relation("RippleToRippleActivity", fields: [rippleId], references: [id])

  @@index([rippleId, createdAt])
}

//summary used for ripple page
model RippleSummary {
  rippleId     String   @id
  participants Int
  actionsTotal Int
  impactValue  Float
  impactUnit   String
  impactSource String
  updatedAt    DateTime @default(now())

  ripple Ripple @relation("RippleToRippleSummary", fields: [rippleId], references: [id])
}

model Ripple {
  id          String  @id @default(cuid())
  waveId      String
  title       String
  description String?
  createdBy   String  @default("system")
  status      String  @default("active")
  //the default initial rippl assigned to users when first registering a wave
  isStarter   Boolean @default(false)

  // Context for Stories
  audience_noun  String?
  context_label  String?
  blurb_template String?
  default_bucket String?

  wave Wave @relation("WaveToRipples", fields: [waveId], references: [id])

  // back-relations (help Prisma disambiguate)
  microActions     MicroAction[]
  memberships      UserRipple[]     @relation("RippleToMemberships")
  actionLogs       ActionLog[]      @relation("RippleToActionLogs")
  rippleActivities RippleActivity[] @relation("RippleToRippleActivity")
  rippleSummary    RippleSummary?   @relation("RippleToRippleSummary")

  @@index([waveId])
}

model MicroAction {
  id        String @id @default(cuid())
  rippleId  String
  text      String
  bucket    String
  status    String @default("active")
  createdBy String @default("system")

  // NEW fields for generation
  waveId     String
  templateId String?
  createdAt  DateTime @default(now())

  ripple     Ripple      @relation(fields: [rippleId], references: [id])
  wave       Wave        @relation("WaveToMicroActions", fields: [waveId], references: [id])
  template   Template?   @relation("TemplateToMicroAction", fields: [templateId], references: [id])
  actionLogs ActionLog[] @relation("MicroActionToActionLogs")

  // ensure bucket is valid for the wave
  waveBucket WaveBucket @relation("MicroActionToWaveBucket", fields: [waveId, bucket], references: [waveId, name])

  @@index([rippleId])
  @@index([waveId, bucket])
}

//completed micro actions
model ActionLog {
  id            String   @id @default(cuid())
  userId        String
  microActionId String
  rippleId      String
  waveId        String
  bucket        String
  createdAt     DateTime @default(now())
  city          String?
  noteText      String? // 0â€“120 chars when present
  shareAnon     Boolean  @default(false)

  //many to one relationship for these: user can have many actionlogs, a microaction can be done multiple times by multiple people, etc
  user   User        @relation("UserToActionLogs", fields: [userId], references: [id])
  micro  MicroAction @relation("MicroActionToActionLogs", fields: [microActionId], references: [id])
  ripple Ripple      @relation("RippleToActionLogs", fields: [rippleId], references: [id])
  wave   Wave        @relation("WaveToActionLogs", fields: [waveId], references: [id])

  @@index([rippleId, createdAt])
  @@index([rippleId, bucket])
  @@index([userId, createdAt])
}
